<!DOCTYPE html>
<html>

<head>
    <title>Malla de poligonos</title>
    <style>
            html,
            body {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        #info {
            position: absolute;
            padding: 10px;
            width: 100%;
            text-align: center;
            color: #030A4B;
        }
    </style>
</head>
    <div id="info">
        <br>
        VISUALIZADOR DE FIGURAS CON MALLAS POLIGONALES<br />
        Usar mouse para mover camara.<br />
        DAVID MORALES - DANIEL PEDROZA- JUAN GOMEZ
        </div>

<body>
    <script src="js/three.min.js"></script>
    <script src="js/controls/OrbitControls.js"></script>
    <script src='js/libs/dat.gui.min.js'></script>
    <script>
        
        class ElementosDeEscenario{
            
            static elementosDeEscenario(bandera) {
                
                var size =50;
                var arrowSize = 10;
                var divisions = size;
                var origin = new THREE.Vector3(0, 0, 0);
                var x = new THREE.Vector3(1, 0, 0);
                var y = new THREE.Vector3(0, 1, 0);
                var z = new THREE.Vector3(0, 0, 1);
                var color1 = new THREE.Color(0xFFFFFF);
                var color2 = new THREE.Color(0x333333);
                var colorR = new THREE.Color(0xAA3333);
                var colorG = new THREE.Color(0x33AA33);
                var colorB = new THREE.Color(0x333366);

                var light = new THREE.DirectionalLight(0x030A4B);
                light.position.set(0, 0, 50);
                scene.add(light);

                //CREAR LAS GRILLAS PARA EL ESCENARIO
                var axesHelper = new THREE.AxesHelper(size);
                var gridHelperXY = new THREE.GridHelper(size, divisions, color2, color2);
                var gridHelperXZ = new THREE.GridHelper(size, divisions, color1, color1);
                var gridHelperYZ = new THREE.GridHelper(size, divisions, color2, color2);

                //ROTARLAS PARA QUE QUEDEN EN EL ESPACIO ADECUADO
                gridHelperXY.rotateOnWorldAxis(x, THREE.Math.degToRad(90));
                gridHelperXZ.rotateOnWorldAxis(y, THREE.Math.degToRad(90));
                gridHelperYZ.rotateOnWorldAxis(z, THREE.Math.degToRad(90));

                //CREAR LAS FLECHAS QUE INDICAN LOS EJES DE COORDENADAS 3D
                var arrowX = new THREE.ArrowHelper(x, origin, arrowSize, colorR);
                var arrowY = new THREE.ArrowHelper(y, origin, arrowSize, colorG);
                var arrowZ = new THREE.ArrowHelper(z, origin, arrowSize, colorB);

                 escenarioGroup= new THREE.Group();
                //  escenarioGroup.add(gridHelperXY);
                //  escenarioGroup.add(gridHelperYZ);
                 escenarioGroup.add(gridHelperXZ);
                //  escenarioGroup.add(arrowX);
                //  escenarioGroup.add(arrowY);     
                //  escenarioGroup.add(arrowZ);

     
                

                return escenarioGroup;
            }            
        }
        class CrearCilindro {
            
                constructor(radio, alto, densidad) {
                    this.radio = radio;
                    this.alto = alto;
                    this.densidad = densidad;
                    var array = [];
                    var matCil = new THREE.MeshBasicMaterial({ color: 'white', vertexColors: THREE.FaceColors });

                }

                static dibujarCilindros(radio, altura, densidad) {
                    scene.remove(figura);   //elimina el anterior elemento de la ecena
                    arrays = [];            //resetea el array que contiene los puntos

                    var geoCilindro = new THREE.Geometry();
                    var increRadC = 3 - densidad;

                    // CREAR PUNTOS CENTRALES
                    // punto central inferior
                    var puntoCentral = new THREE.Vector3(0, 0, 0);
                    geoCilindro.vertices.push(puntoCentral);
                    arrays.push(puntoCentral);
                    // punto central superior
                    var puntoCentral2 = new THREE.Vector3(0, altura, 0);
                    geoCilindro.vertices.push(puntoCentral2);
                    arrays.push(puntoCentral2);


                    // CREA LA NUVE DE PUNTOS (2 CIRCUNFERENCIAS)
                    for (var i = 0; i < 2 * Math.PI; i += increRadC) {
                        for (var j = 0; j < 2; j++) {

                            var punto3 = new THREE.Vector3();
                            punto3.z = (radio * Math.sin(i));
                            punto3.y = (altura * j);
                            punto3.x = (radio * Math.cos(i));
                            geoCilindro.vertices.push(punto3);

                            arrays.push(punto3);
                        }
                    }

                    var bandera = arrays.length; // bandera caras superior e inferior
                    var banderaLateral = arrays.length; // bandera caras laterales

                    for (let index = 0; index < arrays.length; index++) {

                        // caras base inferior
                        if (index % 2 == 0) {
                            if (bandera == 2) { // une cabeza y cola
                                geoCilindro.faces.push(new THREE.Face3(bandera, 0, arrays.length - 2));
                            } else {
                                if (bandera > 2 && bandera < arrays.length) {
                                    geoCilindro.faces.push(new THREE.Face3(bandera, 0, bandera - 2));
                                }
                            }
                        }   // caras base superior
                        else {
                            if (index == arrays.length - 1) { // une cabeza y cola
                                geoCilindro.faces.push(new THREE.Face3(arrays.length - 1, 1, bandera + 2));
                            } else {
                                if (index < arrays.length - 3) {
                                    geoCilindro.faces.push(new THREE.Face3(index + 2, 1, index + 4));
                                }
                            }
                        }
                        bandera -= 1;

                    }

                    // CARAS LATERALES
                    for (let index = 2; index < arrays.length; index++) {
                        if (index + 2 < arrays.length) {
                            geoCilindro.faces.push(new THREE.Face3(index, index + 1, index + 2));

                            geoCilindro.faces.push(new THREE.Face3(banderaLateral - 1, banderaLateral - 2, banderaLateral - 3));
                        }
                        if (index + 2 == arrays.length) { // une cabeza y cola
                            geoCilindro.faces.push(new THREE.Face3(3, 2, index + 1));
                            geoCilindro.faces.push(new THREE.Face3(index, index + 1, 2));
                        }
                        banderaLateral--;
                    }
                    // AÑADIR COLOR ALEATORIO A LAS CARAS
                    for (let index = 0; index < geoCilindro.faces.length; index++) {
                        geoCilindro.faces[index].color.setRGB(Math.random() * 100 / 100, Math.random() * 100 / 100, Math.random() * 100 / 100);
                    }
                    console.log('Caras totales: ' + geoCilindro.faces.length);
                    return geoCilindro;
                }

            }
        class CrearToroide{
            constructor(densidad, miniCircunferencias, radio){
                this.densidad=densidad;
                this.miniCircunferencias=miniCircunferencias;
                this.radio=radio;
            }
            static crearToroide(densidad, miniCircunferencias, rMayor, rMenor){
                scene.remove(figura);
                var geoToroide = new THREE.Geometry();

                var contadorDePuntos = 0;
                for (var i = 0; i < 2 * Math.PI; i += densidad) {
                    contadorDePuntos++;
                    console.log(contadorDePuntos);
                }

                for (var j = 0; j < miniCircunferencias; j += 0.3) {
                    for (var i = 0; i < 2 * Math.PI; i += densidad) {

                        var punto3 = new THREE.Vector3();
                        punto3.z = (rMenor * Math.sin(i));
                        punto3.y = rMenor+rMayor+(rMayor + rMenor * Math.cos(i)) * Math.sin(j);
                        punto3.x = (rMayor + rMenor * Math.cos(i)) * Math.cos(j);
                        geoToroide.vertices.push(punto3);
                        // console.log('i: ' + i);
                    }
                    // console.log('j--> ' + j);
                }


                var bandera = 1;
                for (let index = 0; index < 1; index++) {

                    for (let q = 0; q < geoToroide.vertices.length - 1; q++) {
                        if (bandera == contadorDePuntos) {
                            // console.log(q + ' A -> ' + q + ' ' + (q + 4) + ' ' + (q-3));
                            // console.log(q + ' D -> ' + (q - 3) + ' ' + (q + 4) + ' ' + (q + 1));

                            geoToroide.faces.push(new THREE.Face3(q, q + contadorDePuntos, q - (contadorDePuntos - 1)));
                            geoToroide.faces.push(new THREE.Face3(q - (contadorDePuntos - 1), q + contadorDePuntos, q + 1));
                            bandera = 1;
                            // console.log(' ');

                        } else {
                            if (q + contadorDePuntos < geoToroide.vertices.length - 1) {
                                //console.log(q + ' C -> ' + q + ' ' + (q + 4) + ' ' + (q + 1));
                                // console.log(q + ' B -> ' + (q+1) + ' ' + (q + 4) + ' ' + (q+5));

                                geoToroide.faces.push(new THREE.Face3(q, q + contadorDePuntos, q + 1));
                                geoToroide.faces.push(new THREE.Face3(q + 1, q + contadorDePuntos, q + contadorDePuntos + 1));
                                bandera++;
                            }
                        }

                    }
                }
                // AÑADIR COLOR ALEATORIO A LAS CARAS
                for (let index = 0; index < geoToroide.faces.length; index++) {
                    geoToroide.faces[index].color.setRGB(Math.random() * 100 / 100, Math.random() * 100 / 100, Math.random() * 100 / 100);
                }
                return geoToroide;
            }
            static puntoCentral(rMayor){
                scene.remove(figura);
                var centroToroide = new THREE.Vector3();
                    centroToroide.x = 0;
                    centroToroide.y = rMayor;
                    centroToroide.z = 0;

                    var puntoCentralTorideGeo = new THREE.Geometry();
                    puntoCentralTorideGeo.vertices.push(centroToroide);
                    return puntoCentralTorideGeo;
            }
        }
        class CrearEsfera{
            constructor(){

            }

            static crearEsfera(radio, increRadE, longArco){
                scene.remove(figura);

                var geoEsfera = new THREE.Geometry();
                // var radio = 2;
                // var increRadE = 0.5;
                for (var i = 0; i < Math.PI; i += increRadE) {
                    for (var j = 0; j < longArco * Math.PI; j += increRadE) {

                        var punto2 = new THREE.Vector3();

                        punto2.z = radio * Math.cos(j) * Math.sin(i);
                        punto2.y = (radio * Math.cos(i))+radio;
                        punto2.x = radio * Math.sin(j) * Math.sin(i);
                        geoEsfera.vertices.push(punto2);
                    }
                }

                var contadorPuntos = 0;
                for (var j = 0; j <longArco * Math.PI; j += increRadE) {
                    contadorPuntos++;
                    // console.log('Numero de Puntos: ' + contadorPuntos);
                }



                var contador = 1;
                for (let index = 0; index < geoEsfera.vertices.length - 1; index++) {

                    if (contador == contadorPuntos) {
                        contador = 0;
                        // console.log(' -----------------------------');
                    } else {
                        if (index + contadorPuntos + 1 < geoEsfera.vertices.length) {
                            // console.log('a --> ' + (index + contadorPuntos) + ' ' + (index + contadorPuntos + 1) + ' ' + (index + 1));

                            geoEsfera.faces.push(new THREE.Face3(index + contadorPuntos, index + contadorPuntos + 1, index + 1));

                            if (index >= contadorPuntos) {
                                geoEsfera.faces.push(new THREE.Face3(index + contadorPuntos, index + 1, index));
                            }
                        }
                        if (index > geoEsfera.vertices.length - contadorPuntos - 1) {
                            // console.log('Z> --> ' + (index) + ' ' + (geoEsfera.vertices.length - 1) + ' ' + (index + 1));
                            geoEsfera.faces.push(new THREE.Face3(index, geoEsfera.vertices.length - 1, index + 1));
                        }

                    }
                    contador++;
                }
                for (let index = 0; index <  geoEsfera.faces.length; index++) {
                     geoEsfera.faces[index].color.setRGB(Math.random() * 100 / 100, Math.random() * 100 / 100, Math.random() * 100 / 100);
                }
                return geoEsfera;
            }
        }
        class CrearSemiConoCil {


                constructor() {

                }

                static dibujarSemiConoCil(radio, altura, densidad, punta) {
                    scene.remove(figura);   //elimina el anterior elemento de la ecena
                    arrays = [];            //resetea el array que contiene los puntos

                    var geoSemiCono = new THREE.Geometry();
                    var increRadC = 3 - densidad;

                    // CREAR PUNTOS CENTRALES
                    // punto central inferior
                    var puntoCentral = new THREE.Vector3(0, 0, 0);
                    geoSemiCono.vertices.push(puntoCentral);
                    arrays.push(puntoCentral);
                    // punto central superior
                    var puntoCentral2 = new THREE.Vector3(0, punta, 0);
                    geoSemiCono.vertices.push(puntoCentral2);
                    arrays.push(puntoCentral2);


                    // CREA LA NUVE DE PUNTOS (2 CIRCUNFERENCIAS)
                    for (var i = 0; i < 2 * Math.PI; i += increRadC) {
                        for (var j = 0; j < 2; j++) {

                            var punto3 = new THREE.Vector3();
                            punto3.z = (radio * Math.sin(i));
                            punto3.y = (altura * j);
                            punto3.x = (radio * Math.cos(i));
                            geoSemiCono.vertices.push(punto3);

                            arrays.push(punto3);
                        }
                    }

                    var bandera = arrays.length; // bandera caras superior e inferior
                    var banderaLateral = arrays.length; // bandera caras laterales

                    for (let index = 0; index < arrays.length; index++) {

                        // caras base inferior
                        if (index % 2 == 0) {
                            if (bandera == 2) { // une cabeza y cola
                                geoSemiCono.faces.push(new THREE.Face3(bandera, 0, arrays.length - 2));
                            } else {
                                if (bandera > 2 && bandera < arrays.length) {
                                    geoSemiCono.faces.push(new THREE.Face3(bandera, 0, bandera - 2));
                                }
                            }
                        }   // caras base superior
                        else {
                            if (index == arrays.length - 1) { // une cabeza y cola
                                geoSemiCono.faces.push(new THREE.Face3(arrays.length - 1, 1, bandera + 2));
                            } else {
                                if (index < arrays.length - 3) {
                                    geoSemiCono.faces.push(new THREE.Face3(index + 2, 1, index + 4));
                                }
                            }
                        }
                        bandera -= 1;

                    }

                    // CARAS LATERALES
                    for (let index = 2; index < arrays.length; index++) {
                        if (index + 2 < arrays.length) {
                            geoSemiCono.faces.push(new THREE.Face3(index, index + 1, index + 2));

                            geoSemiCono.faces.push(new THREE.Face3(banderaLateral - 1, banderaLateral - 2, banderaLateral - 3));
                        }
                        if (index + 2 == arrays.length) { // une cabeza y cola
                            geoSemiCono.faces.push(new THREE.Face3(3, 2, index + 1));
                            geoSemiCono.faces.push(new THREE.Face3(index, index + 1, 2));
                        }
                        banderaLateral--;
                    }
                    // AÑADIR COLOR ALEATORIO A LAS CARAS
                    for (let index = 0; index < geoSemiCono.faces.length; index++) {
                        geoSemiCono.faces[index].color.setRGB(Math.random() * 100 / 100, Math.random() * 100 / 100, Math.random() * 100 / 100);
                    }
                    console.log('Caras totales: ' + geoSemiCono.faces.length);
                    console.log(punta);
                    return geoSemiCono;
                }

            }
        class CrearCono{
            static crearCono(radio, altura, increRadC){
                scene.remove(figura);
                var geoCono = new THREE.Geometry();
                var puntaSup = new THREE.Vector3();
                geoCono.vertices.push(puntaSup.set(0, altura, 0));

                var puntaInf = new THREE.Vector3();
                geoCono.vertices.push(puntaInf.set(0, 0, 0));

                for (var i = 0; i < 2 * Math.PI; i += increRadC) {
                    for (var j = 0; j < 1; j++) {

                        var punto3 = new THREE.Vector3();
                        punto3.z = (radio * Math.sin(i));
                        punto3.y =  (altura/2)+(altura * j);
                        punto3.x = (radio * Math.cos(i));
                        geoCono.vertices.push(punto3);
                    }
                }

                for (var i = 2; i <= geoCono.vertices.length - 1; i += 1) {
                    if (i + 1 > geoCono.vertices.length - 1) {
                        geoCono.faces.push(new THREE.Face3(0, 2, geoCono.vertices.length - 1));
                        geoCono.faces.push(new THREE.Face3(1, geoCono.vertices.length - 1, 2));
                    } else {
                        geoCono.faces.push(new THREE.Face3(0, i + 1, i));
                        geoCono.faces.push(new THREE.Face3(1, i, i + 1));
                    }

                }
                for (let index = 0; index < geoCono.faces.length; index++) {
                    geoCono.faces[index].color.setRGB(Math.random() * 100 / 100, Math.random() * 100 / 100, Math.random() * 100 / 100);
                }
                return geoCono;
            }
        }
        class TextoGuia{
            static textoGuia(){
               var loader = new THREE.FontLoader();

                var loader = new THREE.FontLoader();
                loader.load('js/fonts/helvetiker_regular.typeface.json', function (font) {

                    var textGeometry = new THREE.TextGeometry(
                        "Seleccione una figura, establezca sus propiedades y trasladela con WASD ", {

                        font: font,

                        size: 1,
                        height: 0.05,
                        curveSegments: 10,

                        bevelThickness: 1,
                        bevelSize: 1,
                        bevelEnabled: false

                    });

                    var textMaterial = new THREE.MeshPhongMaterial(
                        { color: 0x030B54, specular: 0x3346FF }
                    );

                    mesh = new THREE.Mesh(textGeometry, textMaterial);

                    mesh.position.set(-23, 5, 0)
                    scene.add(mesh);

                });   
            }
        }
        
    </script>
    <script>
        var scene, aspect, camera, renderer, controls;
        var arrays = [], figuras=[];
        var escenarioGroup, cilindro, cubo, toroide, figura, mesh;
        var banderasObj = { upArrow: false, downArrow: false }, leftArrow=false, rightArrow=false;
        var thetaSum = 0;

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(45, aspect, 0.1, 1000);
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            controls = new THREE.OrbitControls(camera, renderer.domElement);

            scene.background= new THREE.Color(0x9c9c9c);

            var onKeyDown = function (event) {
                switch (event.keyCode) {
                    case 87: 
                        banderasObj.upArrow = true;
                        break;
                    case 83: 
                        banderasObj.downArrow = true;
                        break;
                    case 65: 
                        leftArrow = true;
                        break;
                    case 68: 
                        rightArrow = true;
                        break;
                }
            };
            var onKeyUp = function (event) {
                switch (event.keyCode) {
                    case 87: 
                        banderasObj.upArrow = false;
                        break;
                    case 83: 
                        banderasObj.downArrow = false;
                        break;
                    case 65: 
                        leftArrow = false;
                        break;
                    case 68: 
                        rightArrow = false;
                        break;
                }
            };           
            var onKeyLeft = function (event) {
                switch (event.keyCode) {
                    case 87: 
                        banderasObj.upArrow = false;
                        break;
                    case 83: 
                        banderasObj.downArrow = false;
                        break;
                    case 65: 
                        leftArrow = false;
                        break;
                    case 68: 
                        rightArrow = false;
                        break;
                }
            };
            var onKeyRight = function (event) {
                switch (event.keyCode) {
                    case 87:
                        banderasObj.upArrow = true;
                        break;
                    case 83:
                        banderasObj.downArrow = true;
                        break;
                    case 65:
                        leftArrow = true;
                        break;
                    case 68:
                        rightArrow = true;
                        break;
                }
            };
            document.addEventListener('keydown', onKeyDown, false);
            document.addEventListener('keyup', onKeyUp, false);
            document.addEventListener('keyLeft', onKeyLeft, false);
            document.addEventListener('keyRight', onKeyRight, false);

            TextoGuia.textoGuia();

            // MATERIAL 
            var matCil = new THREE.MeshBasicMaterial({ color: 'white', vertexColors: THREE.FaceColors });
            var matPcntls = new THREE.PointsMaterial({ color: 'white', size: 1 });

            var objDatGuiOptios={
                // MALLAS DEL ECENARIO
                escenarioDatGui:true,
                // VARIABLES CILINDRO
                radio:2, // L DEL CUBO, RADIOSEMICONO
                alto:5, // ALTO SEMICONO
                densidad:2.8, //DENSIDAD SEMICONO
                // VARIABLES TOROIDE
                densidadToroide:0.2,
                miniCircunferencias:6.3,
                rMayor:3, 
                rMenor:1,
                // VARIABLES ESFERA
                radioEsfera:2,
                densidadEsfera:0.2,
                longArco:2.1,
                // VARIABLES SEMI-CONO-CILINDRO
                punta:7,
                // ROTAR
                theta:0, sigma:0,

                materializarCilindro: function(){
                    figura = new THREE.Mesh(CrearCilindro.dibujarCilindros(objDatGuiOptios.radio, objDatGuiOptios.alto, objDatGuiOptios.densidad), matCil);
                    scene.add(figura);
                    return figura;
                }, 
                materializarCubo: function () {
                    figura = new THREE.Mesh(CrearCilindro.dibujarCilindros(objDatGuiOptios.radio, objDatGuiOptios.radio*1.5, 1.43), matCil);
                    scene.add(figura);
                    return figura;
                },
                materializarToroide:function(){
                    figura = new THREE.Mesh(CrearToroide.crearToroide(objDatGuiOptios.densidadToroide, objDatGuiOptios.miniCircunferencias, objDatGuiOptios.rMayor, objDatGuiOptios.rMenor), matCil);
                    scene.add(figura);
                    return figura;
                },
                materializarEsfera: function () {
                    figura = new THREE.Mesh(CrearEsfera.crearEsfera(objDatGuiOptios.radioEsfera, objDatGuiOptios.densidadEsfera, objDatGuiOptios.longArco), matCil);
                    scene.add(figura);
                    return figura;
                },
                materializarSemiConoCil: function () {
                    figura = new THREE.Mesh(CrearSemiConoCil.dibujarSemiConoCil(objDatGuiOptios.radio, objDatGuiOptios.alto, objDatGuiOptios.densidad, objDatGuiOptios.punta), matCil);
                    scene.add(figura);
                    return figura;
                },
                materializarCono: function () {
                    figura = new THREE.Mesh(CrearCono.crearCono(objDatGuiOptios.radio, objDatGuiOptios.alto, objDatGuiOptios.densidadEsfera), matCil);
                    scene.add(figura);
                    return figura;
                },
                rotY:function(){
                    var cs = Math.cos(objDatGuiOptios.sigma);
                    var ss = Math.sin(objDatGuiOptios.sigma);
                    var ry = new THREE.Matrix4();
                    ry.set(cs, 0, ss, 0,
                            0, 1, 0, 0,	//Ry
                            -ss, 0, cs, 0,
                            0, 0, 0, 1);
                    figura.applyMatrix(ry)
                },
                rotX: function(){
                    var ct1 = Math.cos(objDatGuiOptios.theta);
                    var st1 = Math.sin(objDatGuiOptios.theta);
                    var rx = new THREE.Matrix4();
                    rx.set(1, 0, 0, 0,
                        0, ct1, -st1, 0,
                        0, st1, ct1, 0,
                        0, 0, 0, 1);
                    figura.applyMatrix(rx)
                },
                establecerFiguras: function(){
                    var tempFigura= figura.clone();
                    scene.add(tempFigura);
                },
                options: 'Seleccione'

            }
            temp = ElementosDeEscenario.elementosDeEscenario(objDatGuiOptios.escenarioDatGui);
            scene.add(temp);
            

            //cilindroInicial = objDatGuiOptios.materializarCilindro();
            var datGuiSelect = new dat.GUI();
            
            var variables = new dat.GUI();
            var rotar = variables.addFolder('Rotar');
            variables.close();
            // VARIABLES DE CADA UNA DE LAS FIGURAS
            var radioCil, altoCil, densidadCil, banderaCil=false;
            var largoCubo, banderaCubo=false;
            var densidadToroide, miniCircunferenciasToroide, rMayor, rMenor, banderaTroide=false;
            var densidadEsfera, radioEsfera, longArco, banderaEsfera=false;
            var punta, banderaSemiCono=false;
            var rotarX, rotarY;
            // se reutilizan algunas variables para el cono
            var banderaCono=false;
            var temp; // GUARDA LAS MAYAS Y LOS EJES DEL ESCENARIO TEMPORALMENTE PARA PODER OCULTARLOS
            datGuiSelect.add(objDatGuiOptios, 'escenarioDatGui').name('Suelo').onChange(function(){
                
                ElementosDeEscenario.elementosDeEscenario(objDatGuiOptios.escenarioDatGui);
                    if(objDatGuiOptios.escenarioDatGui){
                        temp= escenarioGroup;
                        scene.add(temp);
                    }else{
                        scene.remove(temp);
                        console.log(objDatGuiOptios.escenarioDatGui);
                        }
                })

            var barMenu = datGuiSelect.add(objDatGuiOptios, 'options', ['Seleccione','Cilindro', 'Cubo', 'Toroide', 'Esfera','Cono', 'Semi-cono']).name('Figura').listen();
            datGuiSelect.add(objDatGuiOptios, 'establecerFiguras').name('Fijar figura-Button');
            
            rotarX = rotar.add(objDatGuiOptios, 'sigma', -0.45, 0.45).step(Math.PI / 10000).name('Ry').onChange(objDatGuiOptios.rotY);
            rotarY = rotar.add(objDatGuiOptios, 'theta', -0.1, 0.1).step(Math.PI / 10000).name('Rx').onChange(objDatGuiOptios.rotX);

            barMenu.onChange(function (value) {

                variables.open();
                scene.remove(mesh);
                if (value =='Cilindro'){
                        //  LOS IF CON BANDERA... DETECTAN LOS DAT.GUI DE ANTERIORES FIGURAS Y LOS ELIMINAN DE LA ESCENA 
                    if (banderaCubo ) {
                        variables.remove(largoCubo);
                    }
                    if (banderaTroide) {
                        variables.remove(densidadToroide);
                        variables.remove(miniCircunferenciasToroide);
                        variables.remove(rMayor);
                        variables.remove(rMenor);
                    }
                    if (banderaEsfera) {
                        variables.remove(densidadEsfera);
                        variables.remove(radioEsfera);
                        variables.remove(longArco);
                    }
                    if (banderaSemiCono) {
                        variables.remove(punta);
                        variables.remove(radioCil);
                        variables.remove(altoCil);
                        variables.remove(densidadCil);
                    }
                    if (banderaCono) {

                        variables.remove(radioCil);
                        variables.remove(altoCil);
                        variables.remove(densidadCil);
                    }
                    banderaCubo = false;
                    banderaEsfera=false;
                    banderaTroide=false;
                    banderaSemiCono = false;
                    banderaCono=false;
                    banderaCil = true;

                    objDatGuiOptios.materializarCilindro();

                    radioCil= variables.add(objDatGuiOptios, 'radio', 1, 5).step(0.001).name('Radio').onChange(objDatGuiOptios.materializarCilindro);
                    altoCil = variables.add(objDatGuiOptios, 'alto', 1, 10).step(0.001).name('Altura').onChange(objDatGuiOptios.materializarCilindro);
                    densidadCil  = variables.add(objDatGuiOptios, 'densidad', 0.5, 2.9).step(0.00001).name('Densidad').onChange(objDatGuiOptios.materializarCilindro);                
                }
                if (value == 'Cubo') {
                     if (banderaCil) {
                         variables.remove(radioCil);
                         variables.remove(altoCil);
                         variables.remove(densidadCil);
                     }
                     if (banderaEsfera) {
                        variables.remove(densidadEsfera);
                        variables.remove(radioEsfera);
                        variables.remove(longArco);
                    }
                     if (banderaTroide) {
                         variables.remove(densidadToroide);
                         variables.remove(miniCircunferenciasToroide);
                         variables.remove(rMayor);
                         variables.remove(rMenor);
                     }
                    if (banderaSemiCono) {
                        variables.remove(punta);
                        variables.remove(radioCil);
                        variables.remove(altoCil);
                        variables.remove(densidadCil);
                    }
                    if (banderaCono) {

                        variables.remove(radioCil);
                        variables.remove(altoCil);
                        variables.remove(densidadCil);
                    }
                     
                     banderaCil = false;
                     banderaTroide=false;
                     banderaEsfera=false;
                     banderaSemiCono = false;
                     banderaCono = false;
                     banderaCubo = true;
                    
                    objDatGuiOptios.materializarCubo();
                    largoCubo = variables.add(objDatGuiOptios, 'radio', 1, 5).step(0.001).name('L').onChange(objDatGuiOptios.materializarCubo);
                    
                }
                if (value == 'Toroide') {
                    if (banderaCil) {
                        variables.remove(radioCil);
                        variables.remove(altoCil);
                        variables.remove(densidadCil);
                    }
                    if (banderaCubo) {
                        variables.remove(largoCubo);
                    }
                    if (banderaEsfera) {
                        variables.remove(densidadEsfera);
                        variables.remove(radioEsfera);
                        variables.remove(longArco);
                    }
                    if (banderaSemiCono) {
                        variables.remove(punta);
                        variables.remove(radioCil);
                        variables.remove(altoCil);
                        variables.remove(densidadCil);
                    }
                    if (banderaCono) {

                        variables.remove(radioCil);
                        variables.remove(altoCil);
                        variables.remove(densidadCil);
                    }
                    banderaCil = false;
                    banderaCubo = false;
                    banderaEsfera =false;
                    banderaSemiCono = false;
                    banderaCono = false;
                    banderaTroide = true;

                    objDatGuiOptios.materializarToroide();
                    densidadToroide = variables.add(objDatGuiOptios, 'densidadToroide', 0.1, 3).step(0.001).name('Densidad').onChange(objDatGuiOptios.materializarToroide);
                    miniCircunferenciasToroide = variables.add(objDatGuiOptios, 'miniCircunferencias', 0, 6.3).step(0.001).name('Circunferencias').onChange(objDatGuiOptios.materializarToroide);
                    rMayor= variables.add(objDatGuiOptios, 'rMayor', 2, 5).step(0.001).name('Radio Mayor').onChange(objDatGuiOptios.materializarToroide);
                    rMenor = variables.add(objDatGuiOptios, 'rMenor', 1, 4).step(0.001).name('Radio Menor').onChange(objDatGuiOptios.materializarToroide);

                }
                if (value == 'Esfera'){

                    if (banderaCil) {
                        variables.remove(radioCil);
                        variables.remove(altoCil);
                        variables.remove(densidadCil);
                    }
                    if (banderaCubo) {
                        variables.remove(largoCubo);
                    }
                    if (banderaTroide) {
                        variables.remove(densidadToroide);
                        variables.remove(miniCircunferenciasToroide);
                        variables.remove(rMayor);
                        variables.remove(rMenor);
                    }
                    if(banderaSemiCono){
                        variables.remove(punta);
                        variables.remove(radioCil);
                        variables.remove(altoCil);
                        variables.remove(densidadCil);
                    }
                    if (banderaCono) {
                      
                        variables.remove(radioCil);
                        variables.remove(altoCil);
                        variables.remove(densidadCil);
                    }
                    banderaCil = false;
                    banderaCubo = false;
                    banderaTroide = false;
                    banderaSemiCono = false;
                    banderaCono = false;
                    banderaEsfera = true;

                     objDatGuiOptios.materializarEsfera();
                     densidadEsfera = variables.add(objDatGuiOptios, 'densidadEsfera', 0.1, 0.5).step(0.001).name('Densidad').onChange(objDatGuiOptios.materializarEsfera);
                     radioEsfera = variables.add(objDatGuiOptios, 'radioEsfera', 1, 5).step(0.001).name('Radio').onChange(objDatGuiOptios.materializarEsfera);
                     longArco = variables.add(objDatGuiOptios, 'longArco', 0, 2.1).step(0.001).name('Long Arco').onChange(objDatGuiOptios.materializarEsfera);
                }
                if (value == 'Cono') {
                    if (banderaCil) {
                        variables.remove(radioCil);
                        variables.remove(altoCil);
                        variables.remove(densidadCil);
                    }
                    if (banderaCubo) {
                        variables.remove(largoCubo);
                    }
                    if (banderaTroide) {
                        variables.remove(densidadToroide);
                        variables.remove(miniCircunferenciasToroide);
                        variables.remove(rMayor);
                        variables.remove(rMenor);
                    }
                    if (banderaSemiCono) {
                        variables.remove(punta);
                        variables.remove(radioCil);
                        variables.remove(altoCil);
                        variables.remove(densidadCil);
                    }
                     if (banderaCono) {

                        variables.remove(radioCil);
                        variables.remove(altoCil);
                        variables.remove(densidadCil);
                    }
                    banderaCil = false;
                    banderaCubo = false;
                    banderaTroide = false;
                    banderaSemiCono = false;
                    banderaEsfera = false;
                    banderaCono = true;

                    objDatGuiOptios.materializarCono();
                    radioCil = variables.add(objDatGuiOptios, 'radio', 1, 20).step(0.001).name('Radio').onChange(objDatGuiOptios.materializarCono);
                    altoCil = variables.add(objDatGuiOptios, 'alto', 1, 20).step(0.001).name('Altura').onChange(objDatGuiOptios.materializarCono);
                    densidadCil = variables.add(objDatGuiOptios, 'densidadEsfera', 0.1, 2.9).step(0.00001).name('Densidad').onChange(objDatGuiOptios.materializarCono);
                    
                }
                if (value == 'Semi-cono') {
                    //  LOS IF CON BANDERA... DETECTAN LOS DAT.GUI DE ANTERIORES FIGURAS Y LOS ELIMINAN DE LA ESCENA 
                    if (banderaCil) {
                        variables.remove(radioCil);
                        variables.remove(altoCil);
                        variables.remove(densidadCil);
                    }
                    if (banderaCubo) {
                        variables.remove(largoCubo);
                    }
                    if (banderaTroide) {
                        variables.remove(densidadToroide);
                        variables.remove(miniCircunferenciasToroide);
                        variables.remove(rMayor);
                        variables.remove(rMenor);
                    }
                    if (banderaEsfera) {
                        variables.remove(densidadEsfera);
                        variables.remove(radioEsfera);
                        variables.remove(longArco);
                    }
                    if (banderaCono) {

                        variables.remove(radioCil);
                        variables.remove(altoCil);
                        variables.remove(densidadCil);
                    }
                    banderaCubo = false;
                    banderaEsfera = false;
                    banderaTroide = false;
                    banderaCil = false;
                    banderaCono=false;
                    banderaSemiCono=true;

                    objDatGuiOptios.materializarSemiConoCil();

                    radioCil = variables.add(objDatGuiOptios, 'radio', 1, 10).step(0.001).name('Radio').onChange(objDatGuiOptios.materializarSemiConoCil);
                    altoCil = variables.add(objDatGuiOptios, 'alto', 1, 10).step(0.001).name('Altura Cil').onChange(objDatGuiOptios.materializarSemiConoCil);
                    densidadCil = variables.add(objDatGuiOptios, 'densidad', 0.5, 2.9).step(0.00001).name('Densidad').onChange(objDatGuiOptios.materializarSemiConoCil);
                    punta = variables.add(objDatGuiOptios, 'punta', 0, 20).step(0.00001).name('Punta').onChange(objDatGuiOptios.materializarSemiConoCil);
                }
            })
            // ES NECESARIO INICIALIZAR UN OBJETO TIPO THREE PARA QUE LAS MATRICES NO DEN ERROR/ NO ES NECESARIO AÑADIRLO A LA ESCENA 
            figura = new THREE.Mesh(CrearCilindro.dibujarCilindros(objDatGuiOptios.radio, objDatGuiOptios.alto, objDatGuiOptios.densidad), matCil);


            camera.position.x = 0;
            camera.position.y = 10;
            camera.position.z = 45;

            camera.lookAt(origin);
        }

        function animate() {
            render();
            controls.update();
            requestAnimationFrame(animate);
        }

        function render() {
            var theta = 0;		
            var sigma = 0;
            var varTrasnslacion = { tx: 0, ty: 0, tz: 0 };
            if (banderasObj.upArrow) {
                varTrasnslacion.tx = 0; varTrasnslacion.ty = 0; varTrasnslacion.tz = -0.1;    
            }
            if (banderasObj.downArrow) {
                varTrasnslacion.tx = 0; varTrasnslacion.ty = 0; varTrasnslacion.tz = 0.1;
            }
            if(leftArrow){
                varTrasnslacion.tx = -0.1; varTrasnslacion.ty = 0; varTrasnslacion.tz = 0;
            }
            if(rightArrow){
                varTrasnslacion.tx = 0.1; varTrasnslacion.ty = 0; varTrasnslacion.tz = 0;
            }           

            

            var ejesMatrix = new THREE.Matrix4();
            ejesMatrix.set(1, 0, 0, varTrasnslacion.tx,
                           0, 1, 0, varTrasnslacion.ty,
                           0, 0, 1, varTrasnslacion.tz,
                           0, 0, 0, 1);

            figura.matrix.multiply(ejesMatrix); 	//APLICAR LA TRASLACIÓN A NIVEL LOCAL
            var tempMatrix = new THREE.Matrix4();
            
            tempMatrix.copyPosition(figura.matrix);
            figura.applyMatrix(new THREE.Matrix4().getInverse(tempMatrix));
            // figuraGroup.applyMatrix(ry);
            figura.applyMatrix(tempMatrix);
            // camera.lookAt(figura)
            renderer.render(scene, camera);
        }
    </script>
</body>

</html>